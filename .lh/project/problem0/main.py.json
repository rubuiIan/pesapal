{
    "sourceFile": "project/problem0/main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733486335656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733486335656,
            "name": "Commit-0",
            "content": "import os\r\nimport shutil\r\nimport hashlib\r\nimport time\r\nimport difflib\r\n\r\n# --- Repository Initialization ---\r\ndef init_repository():\r\n    if os.path.exists(\".repo\"):\r\n        print(\"Repository already initialized!\")\r\n        return\r\n\r\n    os.mkdir(\".repo\")\r\n    os.mkdir(\".repo/staging\")\r\n    os.mkdir(\".repo/commits\")\r\n    os.mkdir(\".repo/branches\")\r\n\r\n    with open(\".repo/HEAD\", \"w\") as head_file:\r\n        head_file.write(\"refs/heads/main\")\r\n    \r\n    print(\"Initialized empty repository in the current directory.\")\r\n\r\n# --- Staging and Commit ---\r\ndef add_to_staging(file_path):\r\n    if not os.path.exists(\".repo\"):\r\n        print(\"Error: Repository not initialized. Run 'init' first.\")\r\n        return\r\n    \r\n    if not os.path.exists(file_path):\r\n        print(f\"Error: File '{file_path}' does not exist.\")\r\n        return\r\n    \r\n    staging_path = os.path.join(\".repo\", \"staging\", os.path.basename(file_path))\r\n    shutil.copy(file_path, staging_path)\r\n    print(f\"File '{file_path}' added to staging area.\")\r\n\r\ndef commit_files(message):\r\n    if not os.path.exists(\".repo\"):\r\n        print(\"Error: Repository not initialized. Run 'init' first.\")\r\n        return\r\n\r\n    # Get the current branch from the .repo/HEAD file\r\n    with open(\".repo/HEAD\", \"r\") as head_file:\r\n        current_branch = head_file.read().strip().split('/')[-1]\r\n\r\n    staging_path = os.path.join(\".repo\", \"staging\")\r\n    commits_path = os.path.join(\".repo\", \"commits\", current_branch)\r\n\r\n    # Check if staging area is empty\r\n    if not os.listdir(staging_path):\r\n        print(\"Error: No files to commit.\")\r\n        return\r\n\r\n    # Ensure the branch directory exists\r\n    if not os.path.exists(commits_path):\r\n        os.makedirs(commits_path)\r\n\r\n    # Generates a unique commit ID\r\n    commit_id = hashlib.sha1(str(time.time()).encode()).hexdigest()[:10]\r\n\r\n    # Create a new commit folder within the branch folder\r\n    commit_dir = os.path.join(commits_path, commit_id)\r\n    os.mkdir(commit_dir)\r\n\r\n    # Move files from staging to the commit folder\r\n    for file_name in os.listdir(staging_path):\r\n        src = os.path.join(staging_path, file_name)\r\n        dest = os.path.join(commit_dir, file_name)\r\n        shutil.move(src, dest)\r\n\r\n    # Create a commit message file\r\n    with open(os.path.join(commit_dir, \"message.txt\"), \"w\") as msg_file:\r\n        msg_file.write(message)\r\n\r\n    print(f\"Committed files with ID: {commit_id} to branch '{current_branch}'\")\r\n\r\ndef display_commit_log():\r\n    if not os.path.exists(\".repo\"):\r\n        print(\"Error: Repository not initialized. Run 'init' first.\")\r\n        return\r\n\r\n    commits_path = os.path.join(\".repo\", \"commits\")\r\n\r\n    # Check if there are any commits\r\n    if not os.listdir(commits_path):\r\n        print(\"No commits found.\")\r\n        return\r\n\r\n    print(\"Commit History:\\n\")\r\n    for commit_id in sorted(os.listdir(commits_path), reverse=True):\r\n        commit_dir = os.path.join(commits_path, commit_id)\r\n        message_file = os.path.join(commit_dir, \"message.txt\")\r\n\r\n        # Read and display commit message\r\n        with open(message_file, \"r\") as f:\r\n            message = f.read().strip()\r\n\r\n        print(f\"Commit ID: {commit_id}\")\r\n        print(f\"Message: {message}\")\r\n        print(\"-\" * 40)\r\n\r\n# --- Branching Functionality ---\r\ndef create_branch(branch_name):\r\n    if not os.path.exists(\".repo\"):\r\n        print(\"Error: Repository not initialized. Run 'init' first.\")\r\n        return\r\n    \r\n    branches_path = os.path.join(\".repo\", \"branches\")\r\n    \r\n    # Ensure the branches folder exists\r\n    if not os.path.exists(branches_path):\r\n        os.mkdir(branches_path)\r\n\r\n    # Check if the branch already exists\r\n    if os.path.exists(os.path.join(branches_path, branch_name)):\r\n        print(f\"Error: Branch '{branch_name}' already exists.\")\r\n        return\r\n    \r\n    # Create the new branch\r\n    with open(os.path.join(branches_path, branch_name), \"w\") as branch_file:\r\n        branch_file.write(\"refs/heads/main\")\r\n    print(f\"Branch '{branch_name}' created.\")\r\n\r\ndef list_branches():\r\n    if not os.path.exists(\".repo\"):\r\n        print(\"Error: Repository not initialized. Run 'init' first.\")\r\n        return\r\n    \r\n    branches_path = os.path.join(\".repo\", \"branches\")\r\n    \r\n    # Ensure the branches folder exists\r\n    if not os.path.exists(branches_path):\r\n        print(\"No branches found.\")\r\n        return\r\n    \r\n    branches = os.listdir(branches_path)\r\n    if not branches:\r\n        print(\"No branches found.\")\r\n    else:\r\n        print(\"Branches:\")\r\n        for branch in branches:\r\n            print(f\"  {branch}\")\r\n\r\ndef switch_branch(branch_name):\r\n    if not os.path.exists(\".repo\"):\r\n        print(\"Error: Repository not initialized. Run 'init' first.\")\r\n        return\r\n    \r\n    branches_path = os.path.join(\".repo\", \"branches\")\r\n    current_branch_file = os.path.join(\".repo\", \"HEAD\")\r\n\r\n    # Check if the branch exists\r\n    if not os.path.exists(os.path.join(branches_path, branch_name)):\r\n        print(f\"Error: Branch '{branch_name}' does not exist.\")\r\n        return\r\n    \r\n    # Switch to the new branch by updating the HEAD\r\n    with open(current_branch_file, \"w\") as head_file:\r\n        head_file.write(f\"refs/heads/{branch_name}\")\r\n    print(f\"Switched to branch '{branch_name}'.\")\r\n\r\ndef merge_branches(branch1, branch2):\r\n    if not os.path.exists(\".repo\"):\r\n        print(\"Error: Repository not initialized. Run 'init' first.\")\r\n        return\r\n\r\n    branches_path = os.path.join(\".repo\", \"branches\")\r\n\r\n    # Check if branches exist in .repo/branches\r\n    if not os.path.exists(os.path.join(branches_path, branch1)):\r\n        print(f\"Error: Branch '{branch1}' does not exist.\")\r\n        return\r\n    if not os.path.exists(os.path.join(branches_path, branch2)):\r\n        print(f\"Error: Branch '{branch2}' does not exist.\")\r\n        return\r\n\r\n    print(f\"Merging changes from '{branch1}' into '{branch2}'...\")\r\n\r\n    branch1_path = os.path.join(\".repo\", \"commits\", branch1)\r\n    branch2_path = os.path.join(\".repo\", \"commits\", branch2)\r\n\r\n    # Create branch directories if they do not exist\r\n    if not os.path.exists(branch1_path):\r\n        os.mkdir(branch1_path)\r\n    if not os.path.exists(branch2_path):\r\n        os.mkdir(branch2_path)\r\n\r\n    branch1_commits = sorted(os.listdir(branch1_path), reverse=True)\r\n    branch2_commits = sorted(os.listdir(branch2_path), reverse=True)\r\n\r\n    conflict_files = []\r\n    merged_commit_id = hashlib.sha1(str(time.time()).encode()).hexdigest()[:10]\r\n    merged_commit_dir = os.path.join(branch2_path, merged_commit_id)\r\n    os.mkdir(merged_commit_dir)\r\n\r\n    for commit_id in branch1_commits:\r\n        commit_dir = os.path.join(branch1_path, commit_id)\r\n        if os.path.exists(commit_dir):\r\n            for file_name in os.listdir(commit_dir):\r\n                src = os.path.join(commit_dir, file_name)\r\n                dest = os.path.join(branch2_path, merged_commit_id, file_name)\r\n\r\n                if os.path.exists(dest):\r\n                    with open(src, 'r') as file1, open(dest, 'r') as file2:\r\n                        if file1.read() != file2.read():\r\n                            print(f\"Conflict detected in file: {file_name}\")\r\n                            conflict_files.append(file_name)\r\n                            continue\r\n                shutil.copy(src, dest)\r\n\r\n    with open(os.path.join(merged_commit_dir, \"message.txt\"), \"w\") as msg_file:\r\n        msg_file.write(f\"Merged changes from '{branch1}' into '{branch2}'\")\r\n\r\n    if conflict_files:\r\n        print(\"\\nMerge completed with conflicts:\")\r\n        for conflict_file in conflict_files:\r\n            print(f\"  {conflict_file}\")\r\n    else:\r\n        print(\"\\nMerge completed successfully with no conflicts.\")\r\n\r\n    print(f\"Merged commit created: {merged_commit_id}\")\r\n\r\n# --- Diff Functionality ---\r\ndef get_commit_files(branch, commit_id):\r\n    commit_path = os.path.join(\".repo\", \"commits\", branch, commit_id)\r\n    if not os.path.exists(commit_path):\r\n        return []\r\n    return os.listdir(commit_path)\r\n\r\ndef diff_commits(branch1, commit1, branch2, commit2):\r\n    # Get files in both commits\r\n    commit1_files = get_commit_files(branch1, commit1)\r\n    commit2_files = get_commit_files(branch2, commit2)\r\n\r\n    # Compare files that exist in both commits\r\n    common_files = set(commit1_files).intersection(commit2_files)\r\n\r\n    for file in common_files:\r\n        file1_path = os.path.join(\".repo\", \"commits\", branch1, commit1, file)\r\n        file2_path = os.path.join(\".repo\", \"commits\", branch2, commit2, file)\r\n\r\n        with open(file1_path, \"r\") as f1, open(file2_path, \"r\") as f2:\r\n            diff = difflib.unified_diff(f1.readlines(), f2.readlines(), fromfile=file1_path, tofile=file2_path)\r\n            for line in diff:\r\n                print(line)\r\n\r\n    print(f\"Compared commits {commit1} (branch {branch1}) and {commit2} (branch {branch2})\")\r\n\r\n# --- Clone Repository ---\r\ndef clone_repository(remote_path):\r\n    if not os.path.exists(remote_path):\r\n        print(f\"Error: Remote repository '{remote_path}' not found.\")\r\n        return\r\n\r\n    repo_name = os.path.basename(remote_path)\r\n    if os.path.exists(repo_name):\r\n        print(f\"Error: Local directory '{repo_name}' already exists.\")\r\n        return\r\n\r\n    shutil.copytree(remote_path, repo_name)\r\n    print(f\"Cloned repository from '{remote_path}' to '{repo_name}'.\")\r\n\r\n# --- Main Command Handling ---\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    if len(sys.argv) < 2:\r\n        print(\"Usage: python main.py <command> [args]\")\r\n        sys.exit(1)\r\n\r\n    command = sys.argv[1].lower()\r\n\r\n    if command == \"init\":\r\n        init_repository()\r\n    elif command == \"add\":\r\n        if len(sys.argv) < 3:\r\n            print(\"Error: No file specified to add.\")\r\n        else:\r\n            add_to_staging(sys.argv[2])\r\n    elif command == \"commit\":\r\n        if len(sys.argv) < 3:\r\n            print(\"Error: No commit message provided.\")\r\n        else:\r\n            commit_files(\" \".join(sys.argv[2:]))\r\n    elif command == \"log\":\r\n        display_commit_log()\r\n    elif command == \"branch\":\r\n        if len(sys.argv) < 3:\r\n            print(\"Error: No branch name provided.\")\r\n        else:\r\n            create_branch(sys.argv[2])\r\n    elif command == \"list-branches\":\r\n        list_branches()\r\n    elif command == \"switch\":\r\n        if len(sys.argv) < 3:\r\n            print(\"Error: No branch name provided.\")\r\n        else:\r\n            switch_branch(sys.argv[2])\r\n    elif command == \"merge\":\r\n        if len(sys.argv) < 4:\r\n            print(\"Error: Provide two branches to merge.\")\r\n        else:\r\n            merge_branches(sys.argv[2], sys.argv[3])\r\n    elif command == \"diff\":\r\n        if len(sys.argv) < 5:\r\n            print(\"Error: Provide two commits to compare.\")\r\n        else:\r\n            diff_commits(sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])\r\n    elif command == \"clone\":\r\n        if len(sys.argv) < 3:\r\n            print(\"Error: No remote repository path provided.\")\r\n        else:\r\n            clone_repository(sys.argv[2])\r\n    else:\r\n        print(f\"Unknown command: {command}\")\r\n"
        }
    ]
}